[
  {
    "question": "What is the relationship between execution context and scope chain?",
    "options": [
      "They are the same",
      "Execution context creates the scope chain for variable resolution",
      "Scope chain creates execution context",
      "They are unrelated"
    ],
    "correct_answer": "Execution context creates the scope chain for variable resolution",
    "topic": "Execution Context",
    "difficulty": "hard"
  },
  {
    "question": "What are the phases of JavaScript execution?",
    "options": [
      "Parsing and execution",
      "Creation phase and execution phase",
      "Compilation and runtime",
      "Loading and initialization"
    ],
    "correct_answer": "Creation phase and execution phase",
    "topic": "Execution Context",
    "difficulty": "hard"
  },
  {
    "question": "What happens during the creation phase of execution?",
    "options": [
      "Code is executed",
      "Variable and function declarations are hoisted and initialized",
      "Memory is deallocated",
      "Functions are invoked"
    ],
    "correct_answer": "Variable and function declarations are hoisted and initialized",
    "topic": "Execution Context",
    "difficulty": "hard"
  },
  {
    "question": "What is the difference between global execution context and function execution context?",
    "options": [
      "They are identical",
      "Global is created first, function contexts created when functions are called",
      "Function contexts are created first",
      "Only global context exists"
    ],
    "correct_answer": "Global is created first, function contexts created when functions are called",
    "topic": "Execution Context",
    "difficulty": "hard"
  },
  {
    "question": "What is the call stack?",
    "options": [
      "A stack of function calls",
      "A data structure tracking the execution order of functions",
      "A type of array",
      "A memory location"
    ],
    "correct_answer": "A data structure tracking the execution order of functions",
    "topic": "Execution Context",
    "difficulty": "hard"
  },
  {
    "question": "What is the relationship between closures and the scope chain?",
    "options": [
      "Unrelated",
      "Closures maintain references to the scope chain even after the parent function returns",
      "Scope chain creates closures",
      "Closures delete the scope chain"
    ],
    "correct_answer": "Closures maintain references to the scope chain even after the parent function returns",
    "topic": "Closures",
    "difficulty": "hard"
  },
  {
    "question": "What is lexical scoping?",
    "options": [
      "Scope determined at compile time",
      "Scope determined by the physical placement of code in the source file",
      "Scope determined at runtime",
      "Scope determined by execution order"
    ],
    "correct_answer": "Scope determined by the physical placement of code in the source file",
    "topic": "Scope",
    "difficulty": "hard"
  },
  {
    "question": "What is dynamic scoping and why doesn't JavaScript use it?",
    "options": [
      "JavaScript uses dynamic scoping",
      "Scope determined at runtime based on call stack; JavaScript uses lexical scoping for predictability",
      "Dynamic scoping is faster",
      "JavaScript has both"
    ],
    "correct_answer": "Scope determined at runtime based on call stack; JavaScript uses lexical scoping for predictability",
    "topic": "Scope",
    "difficulty": "hard"
  },
  {
    "question": "What is the relationship between this and the execution context?",
    "options": [
      "Unrelated",
      "this is determined by the execution context",
      "this is always the global object",
      "this is determined by the closure"
    ],
    "correct_answer": "this is determined by the execution context",
    "topic": "Execution Context",
    "difficulty": "hard"
  },
  {
    "question": "How does this binding work in different contexts?",
    "options": [
      "Always refers to the global object",
      "Depends on how the function is called (method, function, constructor, or call/apply/bind)",
      "Always refers to the object",
      "Determined by scope chain"
    ],
    "correct_answer": "Depends on how the function is called (method, function, constructor, or call/apply/bind)",
    "topic": "this Keyword",
    "difficulty": "hard"
  },
  {
    "question": "What is the this binding in arrow functions vs regular functions?",
    "options": [
      "Arrow functions have their own this",
      "Arrow functions inherit this from lexical scope, regular functions determine this by call context",
      "Both determine this the same way",
      "Regular functions use lexical scoping"
    ],
    "correct_answer": "Arrow functions inherit this from lexical scope, regular functions determine this by call context",
    "topic": "Arrow Functions",
    "difficulty": "hard"
  },
  {
    "question": "What is implicit this binding?",
    "options": [
      "Explicit binding of this",
      "When this is determined by the object calling the method",
      "When this is not bound",
      "When this is undefined"
    ],
    "correct_answer": "When this is determined by the object calling the method",
    "topic": "this Keyword",
    "difficulty": "hard"
  },
  {
    "question": "What is explicit this binding?",
    "options": [
      "this determined by object",
      "Using call(), apply(), or bind() to explicitly set this",
      "this determined at runtime",
      "this determined by scope"
    ],
    "correct_answer": "Using call(), apply(), or bind() to explicitly set this",
    "topic": "this Keyword",
    "difficulty": "hard"
  },
  {
    "question": "What is the new binding in JavaScript?",
    "options": [
      "Creating new variables",
      "When this is bound to a newly created object via the new keyword",
      "Creating new functions",
      "Creating new scopes"
    ],
    "correct_answer": "When this is bound to a newly created object via the new keyword",
    "topic": "this Keyword",
    "difficulty": "hard"
  },
  {
    "question": "What is the order of this binding precedence?",
    "options": [
      "new > explicit > implicit > default",
      "implicit > explicit > new > default",
      "default > new > explicit > implicit",
      "explicit > implicit > new > default"
    ],
    "correct_answer": "new > explicit > implicit > default",
    "topic": "this Keyword",
    "difficulty": "hard"
  },
  {
    "question": "What is the prototype chain and how does property lookup work?",
    "options": [
      "A chain of prototypes used for property and method lookup",
      "A data structure for inheritance",
      "A way to organize code",
      "A loop mechanism"
    ],
    "correct_answer": "A chain of prototypes used for property and method lookup",
    "topic": "Prototype Chain",
    "difficulty": "hard"
  },
  {
    "question": "What is the difference between [[Prototype]] and prototype property?",
    "options": [
      "They are the same",
      "[[Prototype]] is the internal link, prototype is a property on constructor functions",
      "prototype is internal",
      "[[Prototype]] is external"
    ],
    "correct_answer": "[[Prototype]] is the internal link, prototype is a property on constructor functions",
    "topic": "Prototype Chain",
    "difficulty": "hard"
  },
  {
    "question": "What is the purpose of constructor.prototype?",
    "options": [
      "Stores constructor data",
      "Provides the prototype object for instances created by the constructor",
      "Creates new prototypes",
      "Deletes prototypes"
    ],
    "correct_answer": "Provides the prototype object for instances created by the constructor",
    "topic": "Prototype Chain",
    "difficulty": "hard"
  },
  {
    "question": "What is the relationship between Object.prototype, Function.prototype, and other prototypes?",
    "options": [
      "They are all the same",
      "All built-in objects eventually inherit from Object.prototype through the prototype chain",
      "Function.prototype is separate",
      "They are unrelated"
    ],
    "correct_answer": "All built-in objects eventually inherit from Object.prototype through the prototype chain",
    "topic": "Prototype Chain",
    "difficulty": "hard"
  },
  {
    "question": "What is method overriding in prototypal inheritance?",
    "options": [
      "Preventing method calls",
      "Defining a method in the child that shadows the parent method",
      "Creating multiple methods",
      "A type of error"
    ],
    "correct_answer": "Defining a method in the child that shadows the parent method",
    "topic": "Prototype Chain",
    "difficulty": "hard"
  },
  {
    "question": "What is the difference between class-based and prototype-based inheritance?",
    "options": [
      "They are the same",
      "Classes are syntactic sugar over prototypes; JavaScript uses prototypes internally",
      "JavaScript uses classes only",
      "Prototypes are deprecated"
    ],
    "correct_answer": "Classes are syntactic sugar over prototypes; JavaScript uses prototypes internally",
    "topic": "OOP Concepts",
    "difficulty": "hard"
  },
  {
    "question": "What is the event loop and how does it handle async operations?",
    "options": [
      "A loop that executes code",
      "Coordinates between call stack, callback queue, and Web APIs to manage async operations",
      "A type of function",
      "A memory management system"
    ],
    "correct_answer": "Coordinates between call stack, callback queue, and Web APIs to manage async operations",
    "topic": "Event Loop",
    "difficulty": "hard"
  },
  {
    "question": "What is the difference between the callback queue and the microtask queue?",
    "options": [
      "They are the same",
      "Microtask queue (for Promises) has higher priority and executes before callback queue",
      "Callback queue has higher priority",
      "They execute simultaneously"
    ],
    "correct_answer": "Microtask queue (for Promises) has higher priority and executes before callback queue",
    "topic": "Event Loop",
    "difficulty": "hard"
  },
  {
    "question": "What is starvation in the context of the event loop?",
    "options": [
      "Lack of memory",
      "When long-running code blocks the event loop preventing callbacks from executing",
      "An error condition",
      "A type of bug"
    ],
    "correct_answer": "When long-running code blocks the event loop preventing callbacks from executing",
    "topic": "Event Loop",
    "difficulty": "hard"
  },
  {
    "question": "What is garbage collection in JavaScript?",
    "options": [
      "Collecting garbage",
      "Automatic memory reclamation of unreferenced objects",
      "Deleting files",
      "A user operation"
    ],
    "correct_answer": "Automatic memory reclamation of unreferenced objects",
    "topic": "Memory Management",
    "difficulty": "hard"
  },
  {
    "question": "What is a memory leak?",
    "options": [
      "Leaking data",
      "When objects are retained in memory longer than necessary, preventing garbage collection",
      "A security issue",
      "A type of error"
    ],
    "correct_answer": "When objects are retained in memory longer than necessary, preventing garbage collection",
    "topic": "Memory Management",
    "difficulty": "hard"
  },
  {
    "question": "What causes common memory leaks in JavaScript?",
    "options": [
      "Too many variables",
      "Detached DOM nodes, global variables, unreleased references",
      "Large objects",
      "Type mismatches"
    ],
    "correct_answer": "Detached DOM nodes, global variables, unreleased references",
    "topic": "Memory Management",
    "difficulty": "hard"
  },
  {
    "question": "What is the difference between stack and heap memory?",
    "options": [
      "They are the same",
      "Stack stores primitives and references, heap stores objects",
      "Stack is faster",
      "Heap is temporary"
    ],
    "correct_answer": "Stack stores primitives and references, heap stores objects",
    "topic": "Memory Management",
    "difficulty": "hard"
  },
  {
    "question": "What is the purpose of WeakMap and WeakSet?",
    "options": [
      "Weak versions of Map and Set",
      "Hold weak references allowing garbage collection of keys/values",
      "Deprecated structures",
      "Performance optimization"
    ],
    "correct_answer": "Hold weak references allowing garbage collection of keys/values",
    "topic": "Data Structures",
    "difficulty": "hard"
  },
  {
    "question": "What is the difference between Promise and async/await in error handling?",
    "options": [
      "They are the same",
      "async/await makes error handling clearer with try-catch similar to synchronous code",
      "Promise is better for errors",
      "async/await doesn't handle errors"
    ],
    "correct_answer": "async/await makes error handling clearer with try-catch similar to synchronous code",
    "topic": "Async/Await",
    "difficulty": "hard"
  },
  {
    "question": "What is Promise.allSettled() vs Promise.all()?",
    "options": [
      "They are the same",
      "Promise.all() rejects if any promise rejects, Promise.allSettled() always resolves with all results",
      "Promise.allSettled() fails on error",
      "Promise.all() always succeeds"
    ],
    "correct_answer": "Promise.all() rejects if any promise rejects, Promise.allSettled() always resolves with all results",
    "topic": "Promises",
    "difficulty": "hard"
  },
  {
    "question": "What are unhandled promise rejections and their implications?",
    "options": [
      "Normal errors",
      "Rejected promises without a .catch() or try-catch that can crash the application",
      "A type of warning",
      "Not important"
    ],
    "correct_answer": "Rejected promises without a .catch() or try-catch that can crash the application",
    "topic": "Promises",
    "difficulty": "hard"
  },
  {
    "question": "What is a microtask in JavaScript?",
    "options": [
      "A small task",
      "High-priority tasks (Promises, MutationObserver) executed before macrotasks",
      "A deprecated feature",
      "A function call"
    ],
    "correct_answer": "High-priority tasks (Promises, MutationObserver) executed before macrotasks",
    "topic": "Event Loop",
    "difficulty": "hard"
  },
  {
    "question": "What is the difference between mutable and immutable data structures?",
    "options": [
      "They are the same",
      "Mutable can be modified after creation, immutable cannot",
      "Mutable is better",
      "Immutable is deprecated"
    ],
    "correct_answer": "Mutable can be modified after creation, immutable cannot",
    "topic": "Data Structures",
    "difficulty": "hard"
  },
  {
    "question": "What is structural vs referential equality?",
    "options": [
      "The same",
      "Structural checks values, referential checks if objects are the same instance",
      "Referential is faster",
      "Structural is deprecated"
    ],
    "correct_answer": "Structural checks values, referential checks if objects are the same instance",
    "topic": "Equality",
    "difficulty": "hard"
  },
  {
    "question": "What is the difference between Number and BigInt?",
    "options": [
      "They are the same",
      "Number has precision limits, BigInt can represent arbitrary precision integers",
      "BigInt is faster",
      "Number is deprecated"
    ],
    "correct_answer": "Number has precision limits, BigInt can represent arbitrary precision integers",
    "topic": "Data Types",
    "difficulty": "hard"
  },
  {
    "question": "What is the event delegation pattern?",
    "options": [
      "Delegating to events",
      "Adding a single event listener to a parent to handle events on multiple children",
      "Creating events",
      "A type of error"
    ],
    "correct_answer": "Adding a single event listener to a parent to handle events on multiple children",
    "topic": "DOM Events",
    "difficulty": "hard"
  },
  {
    "question": "What is the difference between event bubbling and capturing?",
    "options": [
      "They are the same",
      "Bubbling goes up the DOM, capturing goes down the DOM",
      "Both go up",
      "Both go down"
    ],
    "correct_answer": "Bubbling goes up the DOM, capturing goes down the DOM",
    "topic": "DOM Events",
    "difficulty": "hard"
  },
  {
    "question": "What is the purpose of event.preventDefault()?",
    "options": [
      "Prevents element creation",
      "Prevents the default action of an event",
      "Stops execution",
      "Deletes elements"
    ],
    "correct_answer": "Prevents the default action of an event",
    "topic": "DOM Events",
    "difficulty": "hard"
  },
  {
    "question": "What is the purpose of event.stopPropagation()?",
    "options": [
      "Stops element propagation",
      "Prevents event from bubbling up to parent elements",
      "Stops execution",
      "Deletes events"
    ],
    "correct_answer": "Prevents event from bubbling up to parent elements",
    "topic": "DOM Events",
    "difficulty": "hard"
  },
  {
    "question": "What is the difference between event.stopPropagation() and event.stopImmediatePropagation()?",
    "options": [
      "They are the same",
      "stopPropagation stops bubbling, stopImmediatePropagation also prevents other handlers on the same element",
      "stopImmediatePropagation stops bubbling",
      "No difference"
    ],
    "correct_answer": "stopPropagation stops bubbling, stopImmediatePropagation also prevents other handlers on the same element",
    "topic": "DOM Events",
    "difficulty": "hard"
  },
  {
    "question": "What is tail call optimization?",
    "options": [
      "Optimizing last function call",
      "When a function's last operation is a function call that can be optimized to use the same stack frame",
      "Recursive function optimization",
      "Compiler feature"
    ],
    "correct_answer": "When a function's last operation is a function call that can be optimized to use the same stack frame",
    "topic": "Performance",
    "difficulty": "hard"
  },
  {
    "question": "What is memoization?",
    "options": [
      "Storing memories",
      "Caching function results based on arguments to avoid redundant computation",
      "A type of memory",
      "Garbage collection"
    ],
    "correct_answer": "Caching function results based on arguments to avoid redundant computation",
    "topic": "Performance",
    "difficulty": "hard"
  },
  {
    "question": "What is debouncing?",
    "options": [
      "Removing bugs",
      "Limiting function calls by waiting for a period of inactivity before executing",
      "A type of function",
      "Throttling"
    ],
    "correct_answer": "Limiting function calls by waiting for a period of inactivity before executing",
    "topic": "Performance",
    "difficulty": "hard"
  },
  {
    "question": "What is throttling?",
    "options": [
      "Limiting speed",
      "Executing a function at most once per specified time interval",
      "Similar to debouncing",
      "Event handling"
    ],
    "correct_answer": "Executing a function at most once per specified time interval",
    "topic": "Performance",
    "difficulty": "hard"
  },
  {
    "question": "What is the difference between debouncing and throttling?",
    "options": [
      "They are the same",
      "Debouncing waits for inactivity, throttling executes at intervals",
      "Throttling is faster",
      "Debouncing is faster"
    ],
    "correct_answer": "Debouncing waits for inactivity, throttling executes at intervals",
    "topic": "Performance",
    "difficulty": "hard"
  },
  {
    "question": "What is lazy evaluation?",
    "options": [
      "Slow evaluation",
      "Computing values only when needed rather than upfront",
      "Performance optimization",
      "A type of function"
    ],
    "correct_answer": "Computing values only when needed rather than upfront",
    "topic": "Performance",
    "difficulty": "hard"
  },
  {
    "question": "What is partial application?",
    "options": [
      "Applying parts",
      "Fixing some arguments of a function and returning a new function",
      "A type of function",
      "Currying"
    ],
    "correct_answer": "Fixing some arguments of a function and returning a new function",
    "topic": "Functional Programming",
    "difficulty": "hard"
  },
  {
    "question": "What is currying?",
    "options": [
      "Related to curry",
      "Transforming a function to accept arguments one at a time",
      "A design pattern",
      "Function composition"
    ],
    "correct_answer": "Transforming a function to accept arguments one at a time",
    "topic": "Functional Programming",
    "difficulty": "hard"
  },
  {
    "question": "What is function composition?",
    "options": [
      "Combining functions",
      "Creating new functions by combining existing functions",
      "A design pattern",
      "A type of inheritance"
    ],
    "correct_answer": "Creating new functions by combining existing functions",
    "topic": "Functional Programming",
    "difficulty": "hard"
  },
  {
    "question": "What is pure function?",
    "options": [
      "A clean function",
      "A function with no side effects that always returns the same output for the same input",
      "A function without parameters",
      "A reserved keyword"
    ],
    "correct_answer": "A function with no side effects that always returns the same output for the same input",
    "topic": "Functional Programming",
    "difficulty": "hard"
  },
  {
    "question": "What is immutability in functional programming?",
    "options": [
      "Mutating data",
      "Data cannot be changed after creation, new data is created instead",
      "Performance feature",
      "Deprecated concept"
    ],
    "correct_answer": "Data cannot be changed after creation, new data is created instead",
    "topic": "Functional Programming",
    "difficulty": "hard"
  },
  {
    "question": "What is tree shaking in module bundlers?",
    "options": [
      "Shaking a tree",
      "Removing unused code during bundling to reduce bundle size",
      "A type of optimization",
      "A reserved keyword"
    ],
    "correct_answer": "Removing unused code during bundling to reduce bundle size",
    "topic": "Modules",
    "difficulty": "hard"
  },
  {
    "question": "What is code splitting?",
    "options": [
      "Splitting code into parts",
      "Dividing code into smaller chunks that can be loaded on demand",
      "A type of optimization",
      "Minification"
    ],
    "correct_answer": "Dividing code into smaller chunks that can be loaded on demand",
    "topic": "Performance",
    "difficulty": "hard"
  },
  {
    "question": "What is the difference between JavaScript specification (ECMAScript) and implementations?",
    "options": [
      "They are the same",
      "Specification defines the standard, implementations are browser/runtime specific",
      "Specification is code",
      "Implementations define the standard"
    ],
    "correct_answer": "Specification defines the standard, implementations are browser/runtime specific",
    "topic": "JavaScript Fundamentals",
    "difficulty": "hard"
  },
  {
    "question": "What is the relationship between Node.js and V8?",
    "options": [
      "They are the same",
      "Node.js uses V8 as its JavaScript engine",
      "V8 uses Node.js",
      "They are unrelated"
    ],
    "correct_answer": "Node.js uses V8 as its JavaScript engine",
    "topic": "JavaScript Runtime",
    "difficulty": "hard"
  },
  {
    "question": "What is JIT compilation in JavaScript engines?",
    "options": [
      "Just-in-time compilation",
      "Compiling code to machine code during runtime for optimization",
      "A type of interpretation",
      "An error handling mechanism"
    ],
    "correct_answer": "Compiling code to machine code during runtime for optimization",
    "topic": "JavaScript Engines",
    "difficulty": "hard"
  },
  {
    "question": "What is inline caching in JavaScript engines?",
    "options": [
      "Caching inline",
      "Optimizing property access by caching type information",
      "A memory feature",
      "A deprecated concept"
    ],
    "correct_answer": "Optimizing property access by caching type information",
    "topic": "JavaScript Engines",
    "difficulty": "hard"
  },
  {
    "question": "What is hidden classes in JavaScript engines?",
    "options": [
      "Secret classes",
      "Internal structures tracking object properties for optimization",
      "A language feature",
      "A deprecated concept"
    ],
    "correct_answer": "Internal structures tracking object properties for optimization",
    "topic": "JavaScript Engines",
    "difficulty": "hard"
  },
  {
    "question": "What is polymorphic inline cache?",
    "options": [
      "Many caches",
      "Caching type information for multiple object shapes",
      "A performance feature",
      "An optimization technique"
    ],
    "correct_answer": "Caching type information for multiple object shapes",
    "topic": "JavaScript Engines",
    "difficulty": "hard"
  },
  {
    "question": "What is the relationship between types and objects in JavaScript?",
    "options": [
      "All objects are instances of types",
      "JavaScript is dynamically typed but objects have internal type information for optimization",
      "Types are separate from objects",
      "No relationship"
    ],
    "correct_answer": "JavaScript is dynamically typed but objects have internal type information for optimization",
    "topic": "Data Types",
    "difficulty": "hard"
  },
  {
    "question": "What is hoisting behavior for function expressions vs function declarations?",
    "options": [
      "Both are hoisted equally",
      "Function declarations are fully hoisted, function expressions are not",
      "Function expressions are hoisted first",
      "Neither is hoisted"
    ],
    "correct_answer": "Function declarations are fully hoisted, function expressions are not",
    "topic": "Hoisting",
    "difficulty": "hard"
  },
  {
    "question": "How does the this keyword behave in strict mode vs non-strict mode?",
    "options": [
      "Identically in both modes",
      "In strict mode, this is undefined in functions; in non-strict, it's the global object",
      "In strict mode, this is the global object",
      "Strict mode doesn't affect this"
    ],
    "correct_answer": "In strict mode, this is undefined in functions; in non-strict, it's the global object",
    "topic": "Execution Context",
    "difficulty": "hard"
  },
  {
    "question": "What is the relationship between async/await and generator functions?",
    "options": [
      "They are unrelated",
      "async/await is built on Promise and generator-like syntax",
      "async/await creates generators",
      "Generators create async functions"
    ],
    "correct_answer": "async/await is built on Promise and generator-like syntax",
    "topic": "Async/Await",
    "difficulty": "hard"
  },
  {
    "question": "How does the JavaScript engine optimize repeated property access?",
    "options": [
      "It doesn't optimize",
      "Through hidden classes and inline caching tracking object shapes",
      "By caching object values",
      "Through memory pooling"
    ],
    "correct_answer": "Through hidden classes and inline caching tracking object shapes",
    "topic": "JavaScript Engines",
    "difficulty": "hard"
  },
  {
    "question": "What happens when a property is added to an object after construction?",
    "options": [
      "The object remains optimized",
      "The engine may change the object's hidden class, affecting optimization",
      "Memory is reallocated",
      "The property is not stored"
    ],
    "correct_answer": "The engine may change the object's hidden class, affecting optimization",
    "topic": "JavaScript Engines",
    "difficulty": "hard"
  },
  {
    "question": "What is the purpose of Object.defineProperty beyond simple property assignment?",
    "options": [
      "Simple assignment only",
      "Controlling enumerability, writability, and configurability of properties",
      "Speeding up assignment",
      "Creating read-only objects"
    ],
    "correct_answer": "Controlling enumerability, writability, and configurability of properties",
    "topic": "Objects",
    "difficulty": "hard"
  },
  {
    "question": "How does destructuring relate to the MutableObjectProto semantics?",
    "options": [
      "They are unrelated",
      "Destructuring uses internal prototype lookup similar to property access",
      "Destructuring bypasses prototypes",
      "No relationship exists"
    ],
    "correct_answer": "Destructuring uses internal prototype lookup similar to property access",
    "topic": "ES6+ Features",
    "difficulty": "hard"
  },
  {
    "question": "What is the observable difference between var and let in temporal dead zone?",
    "options": [
      "No difference",
      "let variables exist in TDZ before declaration; var are initialized to undefined",
      "var has TDZ, let doesn't",
      "They have identical behavior"
    ],
    "correct_answer": "let variables exist in TDZ before declaration; var are initialized to undefined",
    "topic": "Variables",
    "difficulty": "hard"
  },
  {
    "question": "How does the module system affect scope and hoisting?",
    "options": [
      "No effect",
      "Modules create their own scope, and hoisting is module-scoped",
      "Modules prevent hoisting",
      "Hoisting ignores module boundaries"
    ],
    "correct_answer": "Modules create their own scope, and hoisting is module-scoped",
    "topic": "Modules",
    "difficulty": "hard"
  },
  {
    "question": "What is the relationship between Symbol and object property enumeration?",
    "options": [
      "Symbols are enumerated normally",
      "Symbols are not enumerable by default and require special handling",
      "Symbols are always enumerable",
      "Symbols are deprecated"
    ],
    "correct_answer": "Symbols are not enumerable by default and require special handling",
    "topic": "Data Types",
    "difficulty": "hard"
  },
  {
    "question": "How does the for...in loop interact with Symbol properties?",
    "options": [
      "It enumerates Symbols",
      "It skips Symbol properties entirely",
      "It enumerates Symbols first",
      "Behavior depends on browser"
    ],
    "correct_answer": "It skips Symbol properties entirely",
    "topic": "Loops",
    "difficulty": "hard"
  },
  {
    "question": "What is the performance impact of spreading vs concatenating arrays?",
    "options": [
      "They have identical performance",
      "Spreading may allocate new memory, concatenation does too; context matters",
      "Spreading is always faster",
      "Concatenation is always faster"
    ],
    "correct_answer": "Spreading may allocate new memory, concatenation does too; context matters",
    "topic": "Performance",
    "difficulty": "hard"
  },
  {
    "question": "How do modern engines optimize numeric operations vs generic operations?",
    "options": [
      "All operations are generic",
      "Engines use type specialization and Typed Arrays for better numeric performance",
      "Numeric ops are slower",
      "No optimization occurs"
    ],
    "correct_answer": "Engines use type specialization and Typed Arrays for better numeric performance",
    "topic": "JavaScript Engines",
    "difficulty": "hard"
  },
  {
    "question": "What is the relationship between requestAnimationFrame and the event loop?",
    "options": [
      "Unrelated",
      "requestAnimationFrame callbacks are macrotasks synchronized with browser rendering",
      "They are identical",
      "requestAnimationFrame is a microtask"
    ],
    "correct_answer": "requestAnimationFrame callbacks are macrotasks synchronized with browser rendering",
    "topic": "Event Loop",
    "difficulty": "hard"
  },
  {
    "question": "How do modern engines handle megamorphic call sites?",
    "options": [
      "They don't exist",
      "Engines fall back to slower generic code paths when too many object types are seen",
      "All call sites are optimized equally",
      "Megamorphic sites are faster"
    ],
    "correct_answer": "Engines fall back to slower generic code paths when too many object types are seen",
    "topic": "JavaScript Engines",
    "difficulty": "hard"
  }
]